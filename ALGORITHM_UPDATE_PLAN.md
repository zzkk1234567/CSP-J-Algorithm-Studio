# CSP-J 算法工作室 - 算法更新计划

## 第一阶段:优化现有算法描述

### 改进后的算法描述格式

```javascript
{
    id: 'bubble',
    name: '冒泡排序',
    nameEn: 'Bubble Sort',
    type: 'sort',
    difficulty: '⭐⭐',  // 难度星级
    desc: '💡 像气泡上浮一样,每次将最大元素"冒泡"到末尾',
    details: {
        core: '相邻比较,逐步归位',
        time: 'O(n²)',
        space: 'O(1)',
        scene: '小规模数据、教学演示',
        feature: '稳定排序、实现简单'
    },
    code: `...`
}
```

### 优化后的5个现有算法

#### 1. 冒泡排序
- **描述**: 💡 像气泡上浮一样,每次将最大元素"冒泡"到末尾。相邻元素两两比较,大的后移,小的前移,一轮下来最大值到达末尾
- **难度**: ⭐⭐ (入门)
- **时间**: O(n²) | **空间**: O(1)
- **适用**: 小规模数据(n<100)、教学演示
- **特点**: 稳定排序、代码简单、效率较低

#### 2. 选择排序
- **描述**: 🎯 每轮选出最小值放到已排序区域末尾。从未排序区域找到最小元素,与未排序区域第一个元素交换位置
- **难度**: ⭐⭐ (入门)
- **时间**: O(n²) | **空间**: O(1)
- **适用**: 小规模数据、交换次数少的场景
- **特点**: 不稳定排序、交换次数少

#### 3. 插入排序
- **描述**: 🃏 像整理扑克牌一样,将元素插入到已排序序列的正确位置。维护一个有序区,每次将新元素插入正确位置
- **难度**: ⭐⭐ (入门)
- **时间**: O(n²) | **空间**: O(1)
- **适用**: 小规模数据、基本有序的数据
- **特点**: 稳定排序、对基本有序数据效率高

#### 4. 线性查找
- **描述**: 🔍 从头到尾逐个检查,直到找到目标或遍历完所有元素。最简单直接的查找方法
- **难度**: ⭐ (基础)
- **时间**: O(n) | **空间**: O(1)
- **适用**: 无序数据、小规模数据
- **特点**: 实现简单、不要求数据有序

#### 5. 二分查找
- **描述**: ⚡ 在有序数组中每次排除一半元素,快速定位目标。通过比较中间元素,决定在左半还是右半继续查找
- **难度**: ⭐⭐⭐ (中等)
- **时间**: O(log n) | **空间**: O(1)
- **适用**: 有序数据、大规模数据
- **特点**: 效率极高、要求数据有序

---

## 第二阶段:添加核心算法(第一批8个)

### 6. 快速排序 ⭐⭐⭐⭐
- **描述**: 🚀 分治策略的经典应用,选择基准元素,将数组分为小于和大于基准的两部分,递归排序
- **核心**: 选基准、分区、递归
- **时间**: 平均O(n log n),最坏O(n²) | **空间**: O(log n)
- **适用**: 大规模数据、通用排序
- **特点**: 不稳定、平均性能最优、原地排序

### 7. 归并排序 ⭐⭐⭐⭐
- **描述**: 🔀 分治策略,将数组分成两半分别排序,然后合并。稳定且性能稳定的排序算法
- **核心**: 分解、递归、合并
- **时间**: O(n log n) | **空间**: O(n)
- **适用**: 大规模数据、需要稳定排序
- **特点**: 稳定排序、性能稳定、需要额外空间

### 8. 递归算法(阶乘) ⭐⭐
- **描述**: 🔄 函数调用自身解决问题。计算n! = n × (n-1)!,递归到n=1时返回
- **核心**: 递归调用、基准情况
- **时间**: O(n) | **空间**: O(n)
- **适用**: 数学计算、树遍历
- **特点**: 代码简洁、理解递归的基础

### 9. 递推算法(斐波那契) ⭐⭐⭐
- **描述**: ➡️ 从已知推导未知,F(n) = F(n-1) + F(n-2)。动态规划的基础
- **核心**: 状态转移、迭代计算
- **时间**: O(n) | **空间**: O(1)
- **适用**: 数列计算、DP入门
- **特点**: 效率高于递归、空间优化

### 10. 枚举算法(全排列) ⭐⭐⭐
- **描述**: 📋 列举所有可能情况,找到满足条件的解。暴力但有效的问题求解方法
- **核心**: 穷举、剪枝
- **时间**: O(n!) | **空间**: O(n)
- **适用**: 小规模搜索、组合问题
- **特点**: 思路简单、时间复杂度高

### 11. 前缀和 ⭐⭐⭐
- **描述**: ⚡ 预处理数组前缀和,快速计算任意区间和。sum[i,j] = prefix[j] - prefix[i-1]
- **核心**: 预处理、区间查询
- **时间**: 预处理O(n),查询O(1) | **空间**: O(n)
- **适用**: 频繁区间查询、二维矩阵
- **特点**: 空间换时间、查询极快

### 12. 贪心算法(找零钱) ⭐⭐⭐
- **描述**: 💰 每步选择当前最优解,期望得到全局最优。用最少硬币数找零
- **核心**: 局部最优、贪心选择
- **时间**: O(n) | **空间**: O(1)
- **适用**: 最优化问题、特定场景
- **特点**: 效率高、不一定得到最优解

### 13. 简单DP(爬楼梯) ⭐⭐⭐
- **描述**: 🪜 动态规划入门,dp[i] = dp[i-1] + dp[i-2]。记录子问题解,避免重复计算
- **核心**: 状态定义、状态转移
- **时间**: O(n) | **空间**: O(n)或O(1)
- **适用**: 最优子结构问题
- **特点**: DP基础、思想重要

---

## 实现优先级

**立即实现** (用户当前需求):
1. ✅ 优化现有5个算法的描述
2. 🔄 添加算法详细信息展示

**下一步** (根据用户反馈):
- 添加第一批8个核心算法
- 完善可视化效果
- 添加算法对比功能

---

## 用户界面改进

### 算法卡片增强
```html
<div class="algo-card">
    <div class="flex justify-between">
        <span class="icon">📊</span>
        <span class="difficulty">⭐⭐</span>
    </div>
    <h3>冒泡排序</h3>
    <p class="desc">💡 像气泡上浮一样...</p>
    <div class="meta">
        <span>⏱️ O(n²)</span>
        <span>💾 O(1)</span>
    </div>
    <div class="tags">
        <span>稳定排序</span>
        <span>入门级</span>
    </div>
</div>
```

### 详情页增强
- 添加"算法特点"标签
- 添加"适用场景"说明
- 添加"复杂度分析"图表
- 添加"相关算法"推荐
